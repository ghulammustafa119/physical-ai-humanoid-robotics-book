"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[525],{7087(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"gazebo/chapters/chapter1","title":"Chapter 1: Gazebo Overview and Physics Simulation","description":"Introduction to Gazebo as a digital twin platform for humanoid robot physics simulation","source":"@site/docs/gazebo/chapters/chapter1.md","sourceDirName":"gazebo/chapters","slug":"/gazebo/chapters/chapter1","permalink":"/physical-ai-humanoid-robotics-book/docs/gazebo/chapters/chapter1","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Chapter 1: Gazebo Overview and Physics Simulation","description":"Introduction to Gazebo as a digital twin platform for humanoid robot physics simulation","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Modeling Humanoid Robots with URDF","permalink":"/physical-ai-humanoid-robotics-book/docs/ros2/chapters/chapter4"},"next":{"title":"Chapter 2: Sensor Simulation in Gazebo","permalink":"/physical-ai-humanoid-robotics-book/docs/gazebo/chapters/chapter2"}}');var t=i(4848),s=i(8453);const a={title:"Chapter 1: Gazebo Overview and Physics Simulation",description:"Introduction to Gazebo as a digital twin platform for humanoid robot physics simulation",sidebar_position:5},r="Chapter 1: Gazebo Overview and Physics Simulation",l={},c=[{value:"Introduction to Digital Twins in Robotics",id:"introduction-to-digital-twins-in-robotics",level:2},{value:"Gazebo as a Physics Simulation Platform",id:"gazebo-as-a-physics-simulation-platform",level:2},{value:"Physics Engine Fundamentals",id:"physics-engine-fundamentals",level:2},{value:"Gravity Simulation",id:"gravity-simulation",level:3},{value:"Collision Detection and Response",id:"collision-detection-and-response",level:3},{value:"Joint Physics and Constraints",id:"joint-physics-and-constraints",level:3},{value:"Humanoid Robot Simulation Example",id:"humanoid-robot-simulation-example",level:2},{value:"Basic Humanoid Model Configuration",id:"basic-humanoid-model-configuration",level:3},{value:"World File Configuration",id:"world-file-configuration",level:3},{value:"ROS 2 Integration with Python",id:"ros-2-integration-with-python",level:2},{value:"Launch Configuration",id:"launch-configuration",level:3},{value:"Robot State Monitoring",id:"robot-state-monitoring",level:3},{value:"Physics Parameters and Performance Considerations",id:"physics-parameters-and-performance-considerations",level:2},{value:"Time Step Selection",id:"time-step-selection",level:3},{value:"Solver Configuration",id:"solver-configuration",level:3},{value:"Real-time Factor Considerations",id:"real-time-factor-considerations",level:3},{value:"Simulation Environment Architecture",id:"simulation-environment-architecture",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-1-gazebo-overview-and-physics-simulation",children:"Chapter 1: Gazebo Overview and Physics Simulation"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-digital-twins-in-robotics",children:"Introduction to Digital Twins in Robotics"}),"\n",(0,t.jsx)(e.p,{children:"A digital twin in robotics represents a virtual replica of a physical robot and its environment that mirrors real-world behavior with remarkable accuracy. Gazebo serves as a cornerstone of the robotics simulation ecosystem, providing sophisticated physics simulation that enables developers to test, validate, and develop robotic systems without the risks and costs associated with real-world experimentation."}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robots, digital twins are particularly valuable because they allow for safe testing of complex behaviors, validation of control algorithms, and rehearsal of interactions in diverse environments. The digital twin concept encompasses:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physical Model"}),": Accurate representation of robot kinematics, dynamics, and physical properties"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Environmental Model"}),": Simulation of the robot's operating environment with realistic physics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Behavioral Model"}),": Replication of how the robot responds to various stimuli and conditions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Data Model"}),": Integration with real-world sensor data and control systems"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"gazebo-as-a-physics-simulation-platform",children:"Gazebo as a Physics Simulation Platform"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo specializes in the physical and environmental modeling aspects of the digital twin concept. It provides:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics Simulation"}),": Accurate modeling of gravity, collisions, friction, and other physical forces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Simulation"}),": Realistic generation of sensor data that matches real-world behavior"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Environment Creation"}),": Tools for building complex worlds with varied terrains, objects, and lighting conditions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integration Framework"}),": Seamless connection with ROS 2 for bidirectional data flow"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The simulation engine uses advanced physics libraries such as Open Dynamics Engine (ODE), Bullet Physics, or DART to provide realistic interactions between objects. This enables accurate testing of robot behaviors including walking, manipulation, navigation, and environmental interaction."}),"\n",(0,t.jsx)(e.h2,{id:"physics-engine-fundamentals",children:"Physics Engine Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"gravity-simulation",children:"Gravity Simulation"}),"\n",(0,t.jsx)(e.p,{children:"Gravity is the fundamental force that affects all objects in the physical world. In Gazebo, gravity is configured globally for the entire simulation world:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- World file configuration for gravity --\x3e\n<sdf version="1.7">\n  <world name="default">\n    \x3c!-- Set gravity vector (x, y, z) in m/s^2 --\x3e\n    \x3c!-- Default Earth gravity: 9.81 m/s^2 downward --\x3e\n    <gravity>0 0 -9.81</gravity>\n\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Rest of world definition --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsxs)(e.p,{children:["The gravity vector ",(0,t.jsx)(e.code,{children:"(0, 0, -9.81)"})," represents Earth's gravitational acceleration pointing downward along the negative Z-axis. This configuration affects all objects in the simulation, causing them to fall, interact with surfaces, and behave according to gravitational forces."]}),"\n",(0,t.jsx)(e.h3,{id:"collision-detection-and-response",children:"Collision Detection and Response"}),"\n",(0,t.jsx)(e.p,{children:"Collision detection is critical for realistic physics simulation. Gazebo uses sophisticated algorithms to detect when objects intersect and computes appropriate response forces:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example link with collision properties --\x3e\n<link name="robot_link">\n  <collision name="collision">\n    <geometry>\n      <box>\n        <size>0.1 0.1 0.1</size>  \x3c!-- 10cm cube --\x3e\n      </box>\n    </geometry>\n    <surface>\n      <friction>\n        <ode>\n          <mu>1.0</mu>    \x3c!-- Static friction coefficient --\x3e\n          <mu2>1.0</mu2>  \x3c!-- Secondary friction coefficient --\x3e\n        </ode>\n      </friction>\n      <bounce>\n        <restitution_coefficient>0.1</restitution_coefficient>  \x3c!-- Bounciness --\x3e\n        <threshold>100000</threshold>  \x3c!-- Velocity threshold for bouncing --\x3e\n      </bounce>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,t.jsx)(e.p,{children:"The collision properties define how objects interact when they come into contact:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Friction coefficients"})," determine how objects resist sliding against each other"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Restitution coefficient"})," controls how bouncy the collision is (0 = no bounce, 1 = perfectly elastic)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Collision geometry"})," defines the shape used for collision detection (box, sphere, cylinder, mesh)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"joint-physics-and-constraints",children:"Joint Physics and Constraints"}),"\n",(0,t.jsx)(e.p,{children:"Joints connect links in a robot model and define how they can move relative to each other. Each joint type has specific physical properties:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Revolute joint example --\x3e\n<joint name="elbow_joint" type="revolute">\n  <parent link="upper_arm"/>\n  <child link="lower_arm"/>\n  <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>  \x3c!-- Rotation axis (Y-axis) --\x3e\n  <limit lower="-2.0" upper="1.5" effort="20.0" velocity="1.0"/>\n  <dynamics damping="0.1" friction="0.01"/>\n</joint>\n'})}),"\n",(0,t.jsx)(e.p,{children:"Joint properties include:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint type"}),": Fixed, revolute, continuous, prismatic, or floating"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Limit constraints"}),": Range of motion, maximum effort, and velocity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamics"}),": Damping and friction parameters that affect movement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safety controllers"}),": Soft limits and position/velocity constraints"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"humanoid-robot-simulation-example",children:"Humanoid Robot Simulation Example"}),"\n",(0,t.jsx)(e.h3,{id:"basic-humanoid-model-configuration",children:"Basic Humanoid Model Configuration"}),"\n",(0,t.jsx)(e.p,{children:"A humanoid robot in Gazebo requires a properly configured URDF model with appropriate physical properties:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.5"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.5"/>\n      <geometry>\n        <box size="0.3 0.3 0.1"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.5"/>\n      <geometry>\n        <box size="0.3 0.3 0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Spine/Body --\x3e\n  <joint name="base_spine" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.05"/>\n  </joint>\n\n  <link name="torso">\n    <inertial>\n      <mass value="5.0"/>\n      <origin xyz="0 0 0.3"/>\n      <inertia ixx="0.5" ixy="0.0" ixz="0.0" iyy="0.5" iyz="0.0" izz="0.2"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.3"/>\n      <geometry>\n        <box size="0.25 0.25 0.6"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.3"/>\n      <geometry>\n        <box size="0.25 0.25 0.6"/>\n      </geometry>\n    </collision>\n  </link>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"world-file-configuration",children:"World File Configuration"}),"\n",(0,t.jsx)(e.p,{children:"A basic world file provides the environment for the humanoid robot:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_world">\n    \x3c!-- Include default ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include default lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Custom floor with texture --\x3e\n    <model name="floor">\n      <pose>0 0 0 0 0 0</pose>\n      <link name="floor_link">\n        <collision name="floor_collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>10 10</size>\n            </plane>\n          </geometry>\n        </collision>\n        <visual name="floor_visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>10 10</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"ros-2-integration-with-python",children:"ROS 2 Integration with Python"}),"\n",(0,t.jsx)(e.h3,{id:"launch-configuration",children:"Launch Configuration"}),"\n",(0,t.jsx)(e.p,{children:"To run the simulation with ROS 2, you'll need a launch file that integrates with rclpy:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom ament_index_python.packages import get_package_share_directory\n\ndef generate_launch_description():\n    # Launch configuration variables\n    use_sim_time = LaunchConfiguration('use_sim_time')\n\n    # Paths to models and worlds\n    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')\n    world_file = os.path.join(\n        get_package_share_directory('your_robot_description'),\n        'worlds',\n        'humanoid_world.world'\n    )\n\n    # Launch Gazebo server\n    gzserver_cmd = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(pkg_gazebo_ros, 'launch', 'gzserver.launch.py')\n        ),\n        launch_arguments={'world': world_file}.items()\n    )\n\n    # Launch Gazebo client\n    gzclient_cmd = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(pkg_gazebo_ros, 'launch', 'gzclient.launch.py')\n        )\n    )\n\n    # Launch robot state publisher\n    robot_description = os.path.join(\n        get_package_share_directory('your_robot_description'),\n        'urdf',\n        'humanoid.urdf'\n    )\n\n    with open(robot_description, 'r') as infp:\n        robot_desc = infp.read()\n\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{\n            'use_sim_time': use_sim_time,\n            'robot_description': robot_desc\n        }]\n    )\n\n    # Create launch description\n    ld = LaunchDescription()\n    ld.add_action(DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='true',\n        description='Use simulation (Gazebo) clock if true'\n    ))\n    ld.add_action(gzserver_cmd)\n    ld.add_action(gzclient_cmd)\n    ld.add_action(robot_state_publisher)\n\n    return ld\n"})}),"\n",(0,t.jsx)(e.h3,{id:"robot-state-monitoring",children:"Robot State Monitoring"}),"\n",(0,t.jsx)(e.p,{children:"Once the simulation is running, you can monitor the robot state using ROS 2 and rclpy:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist\nimport math\n\nclass HumanoidMonitor(Node):\n    def __init__(self):\n        super().__init__('humanoid_monitor')\n\n        # Subscribe to joint states from the simulated robot\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Publisher for robot commands\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist,\n            '/cmd_vel',\n            10\n        )\n\n        # Timer for periodic status updates\n        self.timer = self.create_timer(1.0, self.status_callback)\n\n        self.joint_positions = {}\n        self.get_logger().info('Humanoid monitor initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Process incoming joint state messages\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.joint_positions[name] = msg.position[i]\n\n        # Log some key joint positions\n        for joint_name in ['elbow_joint', 'knee_joint', 'ankle_joint']:\n            if joint_name in self.joint_positions:\n                angle_deg = math.degrees(self.joint_positions[joint_name])\n                self.get_logger().info(f'{joint_name}: {angle_deg:.2f}\xb0')\n\n    def status_callback(self):\n        \"\"\"Periodic status update\"\"\"\n        if self.joint_positions:\n            self.get_logger().info(f'Monitored {len(self.joint_positions)} joints')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    monitor = HumanoidMonitor()\n\n    try:\n        rclpy.spin(monitor)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        monitor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"physics-parameters-and-performance-considerations",children:"Physics Parameters and Performance Considerations"}),"\n",(0,t.jsx)(e.h3,{id:"time-step-selection",children:"Time Step Selection"}),"\n",(0,t.jsx)(e.p,{children:"The simulation time step is a critical parameter that balances accuracy and performance:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Small time steps"})," (e.g., 0.001s): Higher accuracy, more stable for complex physics, but slower simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Large time steps"})," (e.g., 0.01s): Faster simulation, less accurate, potential instability with complex interactions"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"solver-configuration",children:"Solver Configuration"}),"\n",(0,t.jsx)(e.p,{children:"The physics solver configuration affects both stability and performance:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"More iterations"}),": Better constraint satisfaction, more stable simulation, slower performance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fewer iterations"}),": Faster simulation, potential constraint violations, less stable"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"real-time-factor-considerations",children:"Real-time Factor Considerations"}),"\n",(0,t.jsx)(e.p,{children:"The real-time factor determines how fast the simulation runs compared to real time:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time factor = 1"}),": Simulation runs at the same speed as real time"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time factor > 1"}),": Simulation runs faster than real time (e.g., 2.0 = 2x real time)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time factor < 1"}),": Simulation runs slower than real time (useful for detailed observation)"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"simulation-environment-architecture",children:"Simulation Environment Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The Gazebo simulation environment follows this architectural pattern:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Physical      \u2502    \u2502   Gazebo         \u2502    \u2502   ROS 2         \u2502\n\u2502   Robot World   \u2502    \u2502   Physics        \u2502    \u2502   Middleware    \u2502\n\u2502   (Real/Hardware\u2502    \u2502   Simulation     \u2502    \u2502   (Messages)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                      \u2502                       \u2502\n          \u2502 Real-world           \u2502 Simulated             \u2502 Standard\n          \u2502 Physics & Sensors    \u2502 Physics & Sensors     \u2502 Messages\n          \u2502                      \u2502                       \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   Robotics Applications \u2502\n                    \u2502  (Navigation, Control,  \u2502\n                    \u2502   Perception, etc.)     \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(e.p,{children:"This architecture enables the simulation of complex humanoid robot behaviors while maintaining realistic physics interactions and sensor data generation."}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This chapter has established the foundation for understanding Gazebo as a digital twin platform for humanoid robot simulation. We've explored the physics simulation fundamentals including gravity, collision detection, and joint physics that make realistic robot simulation possible."}),"\n",(0,t.jsx)(e.p,{children:"The setup of humanoid robot simulation requires careful configuration of both the robot model and the environment, with attention to physical properties and performance trade-offs. The parameters chosen for physics simulation significantly impact both the accuracy of the simulation and its computational requirements."}),"\n",(0,t.jsx)(e.p,{children:"In the next chapter, we'll explore how to simulate various sensors in Gazebo, building on these physics fundamentals to create realistic sensor data that can be used for robot development and testing."})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>r});var o=i(6540);const t={},s=o.createContext(t);function a(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);